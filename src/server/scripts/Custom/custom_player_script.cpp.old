/*
* Copyright (C) 2020 BfaCore
*
* This program is free software; you can redistribute it and/or modify it
* under the terms of the GNU General Public License as published by the
* Free Software Foundation; either version 2 of the License, or (at your
* option) any later version.
*
* This program is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
* more details.
*
* You should have received a copy of the GNU General Public License along
* with this program. If not, see <http://www.gnu.org/licenses/>.
*/

#include "Conversation.h"
#include "Creature.h"
#include "DatabaseEnv.h"
#include "DBCEnums.h"
#include "MapManager.h"
#include "ObjectMgr.h"
#include "Player.h"
#include "ScriptedGossip.h"
#include "ScriptMgr.h"
#include "World.h"
#include "WorldSession.h"
#include "Chat.h"
#include "SharedDefines.h"
#include "GameEventMgr.h"
#include "Log.h"


enum Damage_Healing_Debug_Phase {
    AUTOBALANCE_DAMAGE_HEALING_DEBUG_PHASE_BEFORE,
    AUTOBALANCE_DAMAGE_HEALING_DEBUG_PHASE_AFTER
};
/*
enum TalentSpecialization // talent tabs
{
    TALENT_SPEC_MAGE_ARCANE = 62,
    TALENT_SPEC_MAGE_FIRE = 63,
    TALENT_SPEC_MAGE_FROST = 64,
    TALENT_SPEC_PALADIN_HOLY = 65,
    TALENT_SPEC_PALADIN_PROTECTION = 66,
    TALENT_SPEC_PALADIN_RETRIBUTION = 70,
    TALENT_SPEC_WARRIOR_ARMS = 71,
    TALENT_SPEC_WARRIOR_FURY = 72,
    TALENT_SPEC_WARRIOR_PROTECTION = 73,
    TALENT_SPEC_DRUID_BALANCE = 102,
    TALENT_SPEC_DRUID_CAT = 103,
    TALENT_SPEC_DRUID_BEAR = 104,
    TALENT_SPEC_DRUID_RESTORATION = 105,
    TALENT_SPEC_DEATHKNIGHT_BLOOD = 250,
    TALENT_SPEC_DEATHKNIGHT_FROST = 251,
    TALENT_SPEC_DEATHKNIGHT_UNHOLY = 252,
    TALENT_SPEC_HUNTER_BEASTMASTER = 253,
    TALENT_SPEC_HUNTER_MARKSMAN = 254,
    TALENT_SPEC_HUNTER_SURVIVAL = 255,
    TALENT_SPEC_PRIEST_DISCIPLINE = 256,
    TALENT_SPEC_PRIEST_HOLY = 257,
    TALENT_SPEC_PRIEST_SHADOW = 258,
    TALENT_SPEC_ROGUE_ASSASSINATION = 259,
    TALENT_SPEC_ROGUE_COMBAT = 260,
    TALENT_SPEC_ROGUE_SUBTLETY = 261,
    TALENT_SPEC_SHAMAN_ELEMENTAL = 262,
    TALENT_SPEC_SHAMAN_ENHANCEMENT = 263,
    TALENT_SPEC_SHAMAN_RESTORATION = 264,
    TALENT_SPEC_WARLOCK_AFFLICTION = 265,
    TALENT_SPEC_WARLOCK_DEMONOLOGY = 266,
    TALENT_SPEC_WARLOCK_DESTRUCTION = 267,
    TALENT_SPEC_MONK_BREWMASTER = 268,
    TALENT_SPEC_MONK_BATTLEDANCER = 269,
    TALENT_SPEC_MONK_MISTWEAVER = 270,
    TALENT_SPEC_DEMON_HUNTER_HAVOC = 577,
    TALENT_SPEC_DEMON_HUNTER_VENGEANCE = 581
};*/
static std::list<uint32> spellIdsThatSpendPlayerHealth =
{
    45529,      // Blood Tap
    2687,       // Bloodrage
    27869,      // Dark Rune
    16666,      // Demonic Rune
    755,        // Health Funnel (Rank 1)
    3698,       // Health Funnel (Rank 2)
    3699,       // Health Funnel (Rank 3)
    3700,       // Health Funnel (Rank 4)
    11693,      // Health Funnel (Rank 5)
    11694,      // Health Funnel (Rank 6)
    11695,      // Health Funnel (Rank 7)
    27259,      // Health Funnel (Rank 8)
    47856,      // Health Funnel (Rank 9)
    1454,       // Life Tap (Rank 1)
    1455,       // Life Tap (Rank 2)
    1456,       // Life Tap (Rank 3)
    11687,      // Life Tap (Rank 4)
    11688,      // Life Tap (Rank 5)
    11689,      // Life Tap (Rank 6)
    27222,      // Life Tap (Rank 7)
    57946,      // Life Tap (Rank 8)
    29858,      // Soulshatter
    55213,       // Unholy Frenzy
    6603, //auto attack
    75,   //auto shot
    203, //unamred
    5019, //wand shoot
    674, //dual wield
    202, //two handed sword
    199, //two handed maces
    197, //two handed axes
    227, //staves
    201, //one handed sword
    198, //one handed maces
    196, //one handex axes
    15590, //fist weapons
    1180, //daggers
    5011, //crossbows
    264, //bows
    200 //polearms
    

};

// creature IDs that should never be considered clones
// handles cases where a creature is spawned by another creature, but is not a clone (doesn't retain health/mana values)
static std::list<uint32> creatureIDsThatAreNotClones =
{
    16152       // Attumen the Huntsman (Karazhan) combined form
};

// spell IDs that should never be modified
// handles cases where a spell is reflecting damage or otherwise converting player damage to something else
static std::list<uint32> spellIdsToNeverModify =
{
    1177,// Twin Empathy (AQ40 Twin Emperors, only in `spell_dbc` database table)


};

class playerscript_recruiter : public PlayerScript
{
public:
    playerscript_recruiter() : PlayerScript("playerscript_recruiter") {}

    void OnLevelChanged(Player* player, uint8 /*oldLevel*/) override
    {
        if (player->getLevel() != MAX_LEVEL)
            return;
		

        QueryResult result = LoginDatabase.PQuery("SELECT recruiter, recruiter_rewarded FROM account WHERE id = %u", player->GetSession()->GetAccountId());
        if (!result)
            return;

        Field* fields           = result->Fetch();
        uint32 recruiter        = fields[0].GetUInt32();
        bool recruiterRewarded  = fields[1].GetBool();

        if (recruiterRewarded)
            return;

        result = CharacterDatabase.PQuery("SELECT guid, NAME FROM characters WHERE account = %u ORDER BY totaltime DESC LIMIT 1", recruiter);
        if (!result)
            return;

        fields = result->Fetch();
        uint64 recruiterCharacterGUID = fields[0].GetUInt64();

        if (!recruiterCharacterGUID)
            return;

        result = LoginDatabase.PQuery("SELECT COUNT(*) FROM account WHERE recruiter = %u AND recruiter_rewarded = 1", recruiter);
        if (!result)
            return;

        fields = result->Fetch();
        uint32 recruiterRewardCount = fields[0].GetUInt32();
        uint32 rewardItem = 0;

        switch (++recruiterRewardCount)
        {
            case 1: rewardItem = 54860;     break; // X-53 Touring Rocket
            case 2: rewardItem = 37719;     break; // Swift Zhevra
            case 5: rewardItem = 106246;    break; // Emerald Hippogryph
            default: break;
        }

        if (rewardItem)
        {
            CharacterDatabase.PExecute("INSERT INTO character_shop (guid, type, itemId, itemCount) VALUES (" UI64FMTD ", 0, %u, 1)", recruiterCharacterGUID, rewardItem);
            LoginDatabase.PExecute("UPDATE account SET recruiter_rewarded = 1 WHERE id = %u", player->GetSession()->GetAccountId());
        }
    }
};

// TODO : this script is temp fix,
// remove it when legion start quests are properly fixed
class OnLegionArrival : public PlayerScript
{
public:
    OnLegionArrival() : PlayerScript("OnLegionArrival") { }

    enum
    {
        QUEST_THE_LEGION_RETURNS_A = 40519,
        QUEST_THE_LEGION_RETURNS_H = 43926,
        QUEST_BLINK_OF_AN_EYE = 44663,
        QUEST_KHADGARS_DISCOVERY = 44555,

        SPELL_LEGION_LAUNCH_PATCH_QUEST_LAUNCH = 258792,
        SPELL_MAGE_LEARN_GUARDIAN_HALL_TP = 204287,
        SPELL_WAR_LEARN_JUMP_TO_SKYHOLD = 192084,
        SPELL_DRUID_CLASS_HALL_TP = 204874,
        SPELL_CREATE_CLASS_HALL_ALLIANCE = 185506,
        SPELL_CREATE_CLASS_HALL_HORDE = 192191,

        CONVERSATION_KHADGAR_BLINK_OF_EYE = 3827,
    };

    void OnQuestStatusChange(Player* player, uint32 /*questId*/)
    {
        if ((player->IsInAlliance() && player->GetQuestStatus(QUEST_THE_LEGION_RETURNS_A) == QUEST_STATUS_REWARDED) || (player->IsInHorde() && player->GetQuestStatus(QUEST_THE_LEGION_RETURNS_H) == QUEST_STATUS_REWARDED))
        {
            if (player->GetQuestStatus(QUEST_BLINK_OF_AN_EYE) == QUEST_STATUS_NONE)
            {
                Conversation::CreateConversation(CONVERSATION_KHADGAR_BLINK_OF_EYE, player, player->GetPosition(), { player->GetGUID() });

                if (const Quest* quest = sObjectMgr->GetQuestTemplate(QUEST_BLINK_OF_AN_EYE))
                    player->AddQuest(quest, nullptr);
            }
        }
    }

    void OnLogin(Player* player, bool firstLogin) override
    {
        // Can happen in recovery cases
        if (player->getClass()==CLASS_DEMON_HUNTER) // demon hunters legionarrival
        {  
            if ((player->getLevel() >= 100) && (player->getLevel() <= 109))
                if ((player->HasQuest(40373)) || (player->GetQuestStatus(40373) == QUEST_STATUS_REWARDED)) // quest "a new direction"
                    HandleLegionArrival(player);
        }
        else
        {
            if (player->getLevel() >= 100 && firstLogin) // other classes onlegionarrival
                HandleLegionArrival(player);
        }

        if (Map* map = sMapMgr->FindMap(0, 0))
            map->LoadGrid(-11099.8f, -2212.36f);

        if (Map* map = sMapMgr->FindMap(1669, 0))
        {
            map->LoadGrid(459.02f, 1450.02f);
            map->LoadGrid(4682.5f, 9851.57f);
            map->LoadGrid(-2624.08f, 8654.29f);
        }

    }

	///add custom balancing
	///add custom balancing
	///add custom balancing
	///add custom balancing///add custom balancing///add///add custom balancing///add custom balancing///add custom balancing///add custom balancing///add custom balancing///add custom balancing///add custom balancing
	
	
	
	
	
	        void _Debug_Output(std::string function_name, GameObject* target, Unit* source, int32 amount, std::string prefix = "", std::string spell_name = "Unknown Spell", uint32 spell_id = 0)
        {
        
        };


	        void ModifyPeriodicDamageAurasTick(Unit* target, Unit* source, uint32& amount) override
        {
            // if the spell is negative (damage), we need to flip the sign
            // if the spell is positive (healing or other) we keep it the same
           int32 adjustedAmount = amount;

            // only debug if the source or target is a player
           // bool _debug_damage_and_healing = ((source && (source->GetTypeId() == TYPEID_PLAYER || source->IsControlledByPlayer())) || (target && target->GetTypeId() == TYPEID_PLAYER));
            //_debug_damage_and_healing = (source && source->GetMap()->GetInstanceId());

         //   if (_debug_damage_and_healing) _Debug_Output("ModifyPeriodicDamageAurasTick", target, source, adjustedAmount, AUTOBALANCE_DAMAGE_HEALING_DEBUG_PHASE_BEFORE, spellInfo->SpellName[0], spellInfo->Id);

            // set amount to the absolute value of the function call
            // the provided amount doesn't indicate whether it's a positive or negative value
            adjustedAmount = _Modify_Damage_Healing(target, source, adjustedAmount);
            amount = abs(adjustedAmount);

          //  if (_debug_damage_and_healing) _Debug_Output("ModifyPeriodicDamageAurasTick", target, source, adjustedAmount, AUTOBALANCE_DAMAGE_HEALING_DEBUG_PHASE_AFTER, spellInfo->SpellName[0], spellInfo->Id);
        }

        void ModifySpellDamageTaken(Unit* target, Unit* source, int32& amount, SpellInfo const* spellInfo) override
        {
            // if the spell is negative (damage), we need to flip the sign to negative
            // if the spell is positive (healing or other) we keep it the same (positive)
            int32 adjustedAmount = !spellInfo->IsPositive() ? amount * -1 : amount;

            // only debug if the source or target is a player
            //bool _debug_damage_and_healing = ((source && (source->GetTypeId() == TYPEID_PLAYER || source->IsControlledByPlayer())) || (target && target->GetTypeId() == TYPEID_PLAYER));
            //_debug_damage_and_healing = (source && source->GetMap()->GetInstanceId());

           // if (_debug_damage_and_healing) _Debug_Output("ModifySpellDamageTaken", target, source, adjustedAmount, AUTOBALANCE_DAMAGE_HEALING_DEBUG_PHASE_BEFORE, spellInfo->SpellName[0], spellInfo->Id);

            // set amount to the absolute value of the function call
            // the provided amount doesn't indicate whether it's a positive or negative value
            adjustedAmount = _Modify_Damage_Healing(target, source, adjustedAmount, spellInfo);
           // amount = abs(adjustedAmount);
			

           // if (_debug_damage_and_healing) _Debug_Output("ModifySpellDamageTaken", target, source, adjustedAmount, AUTOBALANCE_DAMAGE_HEALING_DEBUG_PHASE_AFTER, spellInfo->SpellName[0], spellInfo->Id);
        }

        void ModifyMeleeDamage(Unit* target, Unit* source, uint32& amount) override
        {
            // melee damage is always negative, so we need to flip the sign to negative
            int32 adjustedAmount = amount * -1;

            // only debug if the source or target is a player
            bool _debug_damage_and_healing = ((source && (source->GetTypeId() == TYPEID_PLAYER || source->IsControlledByPlayer())) || (target && target->GetTypeId() == TYPEID_PLAYER));
            _debug_damage_and_healing = (source && source->GetMap()->GetInstanceId());

           // if (_debug_damage_and_healing) _Debug_Output("ModifyMeleeDamage", target, source, adjustedAmount, AUTOBALANCE_DAMAGE_HEALING_DEBUG_PHASE_BEFORE, "Melee");

            // set amount to the absolute value of the function call
            adjustedAmount = _Modify_Damage_Healing(target, source, adjustedAmount);
            amount = abs(adjustedAmount);

           // if (_debug_damage_and_healing) _Debug_Output("ModifyMeleeDamage", target, source, adjustedAmount, AUTOBALANCE_DAMAGE_HEALING_DEBUG_PHASE_AFTER, "Melee");
        }

        void ModifyHealReceived(Unit* target, Unit* source, uint32& amount, SpellInfo const* spellInfo)
        {
            // healing is always positive, no need for any sign flip

            // only debug if the source or target is a player
           // bool _debug_damage_and_healing = ((source && (source->GetTypeId() == TYPEID_PLAYER || source->IsControlledByPlayer())) || (target && target->GetTypeId() == TYPEID_PLAYER));
           // _debug_damage_and_healing = (source && source->GetMap()->GetInstanceId());

          //  if (_debug_damage_and_healing) _Debug_Output("ModifyHealReceived", target, source, amount, AUTOBALANCE_DAMAGE_HEALING_DEBUG_PHASE_BEFORE, spellInfo->SpellName[0], spellInfo->Id);

            amount = _Modify_Damage_Healing(target, source, amount, spellInfo);

           // if (_debug_damage_and_healing) _Debug_Output("ModifyHealReceived", target, source, amount, AUTOBALANCE_DAMAGE_HEALING_DEBUG_PHASE_AFTER, spellInfo->SpellName[0], spellInfo->Id);
        }

	
	
	       int32 _Modify_Damage_Healing(Unit* target, Unit* source, int32 amount, SpellInfo const* spellInfo = nullptr)
        {
            //
            // Pre-flight Checks
            //

            // only debug if the source or target is a player
           // bool _debug_damage_and_healing = ((source && (source->GetTypeId() == TYPEID_PLAYER || source->IsControlledByPlayer())) || (target && target->GetTypeId() == TYPEID_PLAYER));
          //  _debug_damage_and_healing = (source && source->GetMap()->GetInstanceId());

            // check that we're enabled globally, else return the original value


            // if the source is gone (logged off? despawned?), use the same target and source.
            // hacky, but better than crashing or having the damage go to 1.0x
          //  if (!source)
           // {
             //   if (_debug_damage_and_healing)
             //       TC_LOG_DEBUG("module.AutoBalance_DamageHealingCC", "AutoBalance_UnitScript::_Modify_Damage_Healing: Source is null, using target as source.");

             //   source = target;
         //   }

            // make sure the source and target are in an instance, else return the original damage
         //   if (!(source->GetMap()->IsDungeon() && target->GetMap()->IsDungeon()))
         //   {
                //if (_debug_damage_and_healing)
                //    TC_LOG_DEBUG("module.AutoBalance_DamageHealingCC", "AutoBalance_UnitScript::_Modify_Damage_Healing: Not in an instance, returning original value of ({}).", amount);

              // return amount;  
			   
 			   // since we wannt to modify the everywhere we comment this out we could also add a function here just for world damage etc but no need.
         //   }

            // make sure that the source is in the world, else return the original value
            if (!source->IsInWorld())
            {
                //if (_debug_damage_and_healing)
              //      TC_LOG_DEBUG("module.AutoBalance_DamageHealingCC", "AutoBalance_UnitScript::_Modify_Damage_Healing: Source does not exist in the world, returning original value of ({}).", amount);

                return amount;
            }

            // if the spell ID is in our "never modify" list, return the original value
            if
            (
                spellInfo &&
                spellInfo->Id &&
                std::find
                (
                    spellIdsToNeverModify.begin(),
                    spellIdsToNeverModify.end(),
                    spellInfo->Id
                ) != spellIdsToNeverModify.end()
            )
            {
              //  if (_debug_damage_and_healing)
                //    TC_LOG_DEBUG("module.AutoBalance_DamageHealingCC", "AutoBalance_UnitScript::_Modify_Damage_Healing: Spell {}({}) is in the never modify list, returning original value of ({}).",
                    //    spellInfo->SpellName[0],
                  //      spellInfo->Id,
                 //       amount
                 //   );

                return amount;
            }

    
         
            //
            // Multiplier calculation
            //
            float damageMultiplier = 1.0f;

         
            // otherwise, use the source creature's damage multiplier
     

	
	
	//damageMultiplier=1; // just to make sure
	if ((source->GetTypeId() == TYPEID_UNIT && amount < 0) && target->IsPlayer()) //unit attacks on players, tank balancing
	{
		uint8 BwlowHighItemLevelBufftanks =1;
        uint8 TalentSpecalization = target->ToPlayer()->GetSpecializationId(); //get main spec
		if (target->ToPlayer()->GetAverageItemLevelEquipped() > 150)
			{
			 BwlowHighItemLevelBufftanks = (((target->ToPlayer()->GetAverageItemLevelEquipped()/264)-1)/2)+1;  // 264 is 100 % anything above 264 is bonus and no need to balance beyond that for op specs;
				if(BwlowHighItemLevelBufftanks < 1 ||BwlowHighItemLevelBufftanks > 1.12) 
				{
					BwlowHighItemLevelBufftanks =1; //to make sure nothing gets nerfed higher than 264 or lower than around 189.
				
				}
			}
				switch (TalentSpecalization) {
				case TALENT_SPEC_MAGE_ARCANE:          // 62
                    damageMultiplier = 0.1f;
					break;
				case TALENT_SPEC_MAGE_FIRE:            // 63
					break;
				case TALENT_SPEC_MAGE_FROST:           // 64
					break;
				case TALENT_SPEC_PALADIN_HOLY:         // 65
					break;
				case TALENT_SPEC_PALADIN_PROTECTION:     // 66
					break;
				case TALENT_SPEC_PALADIN_RETRIBUTION:   // 70
					break;
				case TALENT_SPEC_WARRIOR_ARMS:          // 71
					break;
				case TALENT_SPEC_WARRIOR_FURY:           // 72
					break;
				case TALENT_SPEC_WARRIOR_PROTECTION:     // 73
					break;
				case TALENT_SPEC_DRUID_BALANCE:         // 102
					break;
				case TALENT_SPEC_DRUID_CAT:             // 103
					break;
				case TALENT_SPEC_DRUID_BEAR:            // 104
					break;
				case TALENT_SPEC_DRUID_RESTORATION:      // 105
					break;
				case TALENT_SPEC_DEATHKNIGHT_BLOOD:       // 250
					break;
				case TALENT_SPEC_DEATHKNIGHT_FROST:       // 251
					break;
				case TALENT_SPEC_DEATHKNIGHT_UNHOLY:      // 252
					break;
				case TALENT_SPEC_HUNTER_BEASTMASTER:     // 253
					break;
				case TALENT_SPEC_HUNTER_MARKSMAN:         // 254
					break;
				case TALENT_SPEC_HUNTER_SURVIVAL:          // 255
					break;
				case TALENT_SPEC_PRIEST_DISCIPLINE:       // 256
					break;
				case TALENT_SPEC_PRIEST_HOLY:             // 257
					break;
				case TALENT_SPEC_PRIEST_SHADOW:            // 258
					break;
				case TALENT_SPEC_ROGUE_ASSASSINATION:      // 259
					break;
				case TALENT_SPEC_ROGUE_COMBAT:              // 260
					break;
				case TALENT_SPEC_ROGUE_SUBTLETY:           // 261
					break;
				case TALENT_SPEC_SHAMAN_ELEMENTAL:         // 262
					break;
				case TALENT_SPEC_SHAMAN_ENHANCEMENT:       // 263
					break;
				case TALENT_SPEC_SHAMAN_RESTORATION:       // 264
					break;
				case TALENT_SPEC_WARLOCK_AFFLICTION:      // 265
					break;
				case TALENT_SPEC_WARLOCK_DEMONOLOGY:       // 266
					break;
				case TALENT_SPEC_WARLOCK_DESTRUCTION:     // 267
					break;
				case TALENT_SPEC_MONK_BREWMASTER:          // 268
					break;
				case TALENT_SPEC_MONK_BATTLEDANCER:         // 269
					break;
				case TALENT_SPEC_MONK_MISTWEAVER:           // 270
					break;
				case TALENT_SPEC_DEMON_HUNTER_HAVOC:       // 577
					break;
				case TALENT_SPEC_DEMON_HUNTER_VENGEANCE:   // 581
					break;
			}
	}
	
	if(source->IsPlayer()) // buff  or nerf damage, could just copy paste or add exceptions both works, like dk pve and pvp, can split when wanted.
	{				
	        uint8 FixLowIlevelDamageFactor = 1;
	        uint8 FixHighIlevelDamageFactor = 1;
			        //maxIndex 0 means no talents, 0 means first tree, 1 means second 2 means thrid
			        damageMultiplier = 100;
		        	if (source->ToPlayer()->GetAverageItemLevelEquipped() > 150)
			        {
                     FixLowIlevelDamageFactor = (((source->ToPlayer()->GetAverageItemLevelEquipped() /264)-1)/2)+1;  // 264 is 100 % anything above 264 is bonus and no need to balance beyond that for op specs;
				        if(FixLowIlevelDamageFactor < 1)
				        {
					        FixLowIlevelDamageFactor =1; //to make sure nothing gets nerfed higher than 264 
				        }
			        }
			        if(source->ToPlayer()->GetAverageItemLevelEquipped() > 218) //
			        {
                     FixHighIlevelDamageFactor = (((((source->ToPlayer()->GetAverageItemLevelEquipped()-264)+60)/7)/100)+1);  //balance up at 264+ it is 9 %
				        if(FixHighIlevelDamageFactor < 1)
				        {
					        FixHighIlevelDamageFactor =1; //to make sure nothing gets nerfed higher than 264 
				        }
			        }
                   
	    uint8 TalentSpecalization = source->ToPlayer()->GetSpecializationId(); //get main spec
			switch (TalentSpecalization) {
				case TALENT_SPEC_MAGE_ARCANE:          // 62
                    damageMultiplier = 4.f;
					break;
				case TALENT_SPEC_MAGE_FIRE:            // 
                    damageMultiplier = 10.f;
					break;
				case TALENT_SPEC_MAGE_FROST:           // 64
                    damageMultiplier = 20.0f;
					break;
				case TALENT_SPEC_PALADIN_HOLY:         // 65
					break;
				case TALENT_SPEC_PALADIN_PROTECTION:     // 66
					break;
				case TALENT_SPEC_PALADIN_RETRIBUTION:   // 70
					break;
				case TALENT_SPEC_WARRIOR_ARMS:          // 71
					break;
				case TALENT_SPEC_WARRIOR_FURY:           // 72
					break;
				case TALENT_SPEC_WARRIOR_PROTECTION:     // 73
					break;
				case TALENT_SPEC_DRUID_BALANCE:         // 102
					break;
				case TALENT_SPEC_DRUID_CAT:             // 103
					break;
				case TALENT_SPEC_DRUID_BEAR:            // 104
					break;
				case TALENT_SPEC_DRUID_RESTORATION:      // 105
					break;
				case TALENT_SPEC_DEATHKNIGHT_BLOOD:       // 250
					break;
				case TALENT_SPEC_DEATHKNIGHT_FROST:       // 251
					break;
				case TALENT_SPEC_DEATHKNIGHT_UNHOLY:      // 252
					break;
				case TALENT_SPEC_HUNTER_BEASTMASTER:     // 253
					break;
				case TALENT_SPEC_HUNTER_MARKSMAN:         // 254
					break;
				case TALENT_SPEC_HUNTER_SURVIVAL:          // 255
					break;
				case TALENT_SPEC_PRIEST_DISCIPLINE:       // 256
					break;
				case TALENT_SPEC_PRIEST_HOLY:             // 257
					break;
				case TALENT_SPEC_PRIEST_SHADOW:            // 258
					break;
				case TALENT_SPEC_ROGUE_ASSASSINATION:      // 259
					break;
				case TALENT_SPEC_ROGUE_COMBAT:              // 260
					break;
				case TALENT_SPEC_ROGUE_SUBTLETY:           // 261
					break;
				case TALENT_SPEC_SHAMAN_ELEMENTAL:         // 262
					break;
				case TALENT_SPEC_SHAMAN_ENHANCEMENT:       // 263
					break;
				case TALENT_SPEC_SHAMAN_RESTORATION:       // 264
					break;
				case TALENT_SPEC_WARLOCK_AFFLICTION:      // 265
					break;
				case TALENT_SPEC_WARLOCK_DEMONOLOGY:       // 266
					break;
				case TALENT_SPEC_WARLOCK_DESTRUCTION:     // 267
					break;
				case TALENT_SPEC_MONK_BREWMASTER:          // 268
					break;
				case TALENT_SPEC_MONK_BATTLEDANCER:         // 269
					break;
				case TALENT_SPEC_MONK_MISTWEAVER:           // 270
					break;
				case TALENT_SPEC_DEMON_HUNTER_HAVOC:       // 577
					break;
				case TALENT_SPEC_DEMON_HUNTER_VENGEANCE:   // 581
					break;
			}
               
	
	}
		
            // we are good to go, return the original damage times the multiplier
            //if (_debug_damage_and_healing)
             //   TC_LOG_DEBUG("module.AutoBalance_DamageHealingCC", "AutoBalance_UnitScript::_Modify_Damage_Healing: Returning modified {}: ({}) * ({}) = ({})",
             //       amount <= 0 ? "damage" : "healing",
             //       amount,
              //      damageMultiplier,
              //      amount * damageMultiplier
              //  );
    amount *= damageMultiplier;
            return (amount);
}

	///end custom balancing///end custom balancing///end custom balancing///end custom balancing///end custom balancing///end custom balancing///end custom balancing///end custom balancing
	///end custom balancing///end custom balancing///end custom balancing///end custom balancing///end custom balancing///end custom balancing///end custom balancing///end custom balancing///end custom balancing///end custom balancing
	

    void OnLevelChanged(Player* player, uint8 oldLevel) override
    {
        if (oldLevel < 100 && player->getLevel() >= 100)
        {
            if (player->getClass()==CLASS_DEMON_HUNTER) // demon hunters legionarrival
            {  
                if ((player->HasQuest(40373)) || (player->GetQuestStatus(40373) == QUEST_STATUS_REWARDED)) // quest "a new direction"
                    HandleLegionArrival(player);
            }
            else
                HandleLegionArrival(player);
        }
    }

    void HandleLegionArrival(Player* player)
    {
        switch (player->getClass())
        {
        case CLASS_MAGE:
            player->CastSpell(player, SPELL_MAGE_LEARN_GUARDIAN_HALL_TP, true);
            break;
        case CLASS_WARRIOR:
            player->CastSpell(player, SPELL_WAR_LEARN_JUMP_TO_SKYHOLD, true);
            break;
        case CLASS_DRUID:
            player->CastSpell(player, SPELL_DRUID_CLASS_HALL_TP, true);
            break;
        case CLASS_HUNTER:
            player->m_taxi.SetTaximaskNode(1848); // Hunter Class Hall
            break;
        default:
            break;
        }

        ///QUEST_THE_LEGION_RETURNS
        player->CastSpell(player, SPELL_LEGION_LAUNCH_PATCH_QUEST_LAUNCH, true);

        if ((player->IsInAlliance() && player->GetQuestStatus(QUEST_THE_LEGION_RETURNS_A) == QUEST_STATUS_REWARDED) || (player->IsInHorde() && player->GetQuestStatus(QUEST_THE_LEGION_RETURNS_H) == QUEST_STATUS_REWARDED))
        {
            if (player->GetQuestStatus(QUEST_BLINK_OF_AN_EYE) == QUEST_STATUS_NONE)
            {
                Conversation::CreateConversation(CONVERSATION_KHADGAR_BLINK_OF_EYE, player, player->GetPosition(), { player->GetGUID() });

                if (const Quest* quest = sObjectMgr->GetQuestTemplate(QUEST_BLINK_OF_AN_EYE))
                    player->AddQuest(quest, nullptr);
            }
        }

        if (player->GetQuestStatus(QUEST_BLINK_OF_AN_EYE) == QUEST_STATUS_REWARDED)
            HandleGetAfterBlinkOfAnEye(player);
    }

    void OnQuestComplete(Player* player, Quest const* quest)
    {
        /* demon hunters legionarrival */
        if (player->getClass()==CLASS_DEMON_HUNTER)
            if ((quest->GetQuestId() == 40373) && (player->getLevel() >= 100)) // quest "a new direction"
                HandleLegionArrival(player);

        if (quest->GetQuestId() == QUEST_BLINK_OF_AN_EYE)
            HandleGetAfterBlinkOfAnEye(player);
    }

    void HandleGetAfterBlinkOfAnEye(Player* player)
    {
        if (player->GetQuestStatus(QUEST_KHADGARS_DISCOVERY) == QUEST_STATUS_NONE)
            if (const Quest* quest = sObjectMgr->GetQuestTemplate(QUEST_KHADGARS_DISCOVERY))
                player->AddQuest(quest, nullptr);

        if (uint32 artifact_knowledge = sWorld->getIntConfig(CONFIG_CURRENCY_START_ARTIFACT_KNOWLEDGE))
        {
            if (artifact_knowledge > 10)
                player->CompletedAchievement(10852);
            if (artifact_knowledge > 24)
                player->CompletedAchievement(10853);
        }

        player->CastSpell(player, player->IsInAlliance() ? SPELL_CREATE_CLASS_HALL_ALLIANCE : SPELL_CREATE_CLASS_HALL_HORDE, true);
        HandleGetFirstFollower(player);
    }

    void HandleGetFirstFollower(Player* player)
    {
        if (player->GetQuestStatus(QUEST_BLINK_OF_AN_EYE) == QUEST_STATUS_COMPLETE || player->GetQuestStatus(QUEST_BLINK_OF_AN_EYE) == QUEST_STATUS_REWARDED)
        {
            switch (player->getClass())
            {
            case CLASS_WARRIOR:
                player->CastSpell(player, 198182, true);
                break;
            case CLASS_PALADIN:
                player->CastSpell(player, 181009, true);
                break;
            case CLASS_HUNTER:
                player->CastSpell(player, 203376, true);
                break;
            case CLASS_ROGUE:
                player->CastSpell(player, 235468, true);
                break;
            case CLASS_PRIEST:
                player->CastSpell(player, 219764, true);
                break;
            case CLASS_DEATH_KNIGHT:
                player->CastSpell(player, 191521, true);
                break;
            case CLASS_SHAMAN:
                player->CastSpell(player, 211710, true);
                break;
            case CLASS_MAGE:
                player->CastSpell(player, 217305, true);
                break;
            case CLASS_WARLOCK:
                player->CastSpell(player, 201163, true);
                break;
            case CLASS_MONK:
                player->CastSpell(player, 234265, true);
                break;
            case CLASS_DRUID:
                player->CastSpell(player, 210357, true);
                break;
            case CLASS_DEMON_HUNTER:
                player->CastSpell(player, player->IsInAlliance() ? 188249 : 215133, true);
                break;
            default:
                break;
            }
        }
        player->CastSpell(player, 164608, true);
    }
};

// TODO : this script is temp fix
class On110Arrival : public PlayerScript
{
public:
    On110Arrival() : PlayerScript("On110Arrival") { }

    enum
    {
        QUEST_UNITING_THE_ISLES = 43341,
        QUEST_ARMIES_OF_LEGIONFALL = 46730,
        QUEST_WHISPERS_OF_A_FRIGHTENED_WORLD = 46206,

        SPELL_LEGION_7_2_PATCH_QUEST_LAUNCH = 239624,
    };

    void OnLogin(Player* player, bool firstLogin) override
    {
        // Can happen in recovery cases
        if (player->getLevel() >= 110 && firstLogin)
            Handle110Arrival(player);
    }

    void OnLevelChanged(Player* player, uint8 oldLevel) override
    {
        if (oldLevel < 110 && player->getLevel() >= 110)
            Handle110Arrival(player);
    }

    void Handle110Arrival(Player* player)
    {
        if (player->GetQuestStatus(QUEST_UNITING_THE_ISLES) == QUEST_STATUS_NONE)
            if (const Quest* quest = sObjectMgr->GetQuestTemplate(QUEST_UNITING_THE_ISLES))
                player->AddQuest(quest, nullptr);
        if (player->GetQuestStatus(QUEST_ARMIES_OF_LEGIONFALL) == QUEST_STATUS_NONE)
            player->CastSpell(player, SPELL_LEGION_7_2_PATCH_QUEST_LAUNCH, true);
        //if (player->GetQuestStatus(QUEST_WHISPERS_OF_A_FRIGHTENED_WORLD) == QUEST_STATUS_NONE)
        //    player->CastSpell(player, SPELL_WHISPERS_OF_A_FRIGHTENED_WORLD_PUSH, true);
    }
};

// TODO : this script is temp fix,
// remove it when lordaeron battle is properly fixed
class OnBfaArrival : public PlayerScript
{
public:
    OnBfaArrival() : PlayerScript("OnBfaArrival") { }

    enum
    {
        QUEST_DYING_WORLD_A                 = 52946,
        QUEST_DYING_WORLD_H                 = 53028,

        SPELL_CREATE_WAR_CAMPAIGN_H         = 273381,
        SPELL_CREATE_WAR_CAMPAIGN_A         = 273382,

        CONVERSATION_MAGNI_DYING_WORLD      = 9316,
    };

    void OnLogin(Player* player, bool /*firstLogin*/) override
    {
        if (player->getLevel() >= 110)
            HandleBFAStart(player);
    }

    void OnLevelChanged(Player* player, uint8 oldLevel) override
    {
        if (oldLevel < 110 && player->getLevel() >= 110)
            HandleBFAStart(player);
    }

    void HandleBFAStart(Player* player)
    {
        if (player->GetQuestStatus(QUEST_DYING_WORLD_A) == QUEST_STATUS_NONE &&
            player->GetQuestStatus(QUEST_DYING_WORLD_H) == QUEST_STATUS_NONE)
        {
            player->CastSpell(player, player->IsInAlliance() ? SPELL_CREATE_WAR_CAMPAIGN_A : SPELL_CREATE_WAR_CAMPAIGN_H, true);

            Conversation::CreateConversation(CONVERSATION_MAGNI_DYING_WORLD, player, player->GetPosition(), { player->GetGUID() });

            if (const Quest* quest = sObjectMgr->GetQuestTemplate(player->IsInAlliance() ? QUEST_DYING_WORLD_A : QUEST_DYING_WORLD_H))
                player->AddQuest(quest, nullptr);
        }
    }
};

// TODO : this script is temp fix,
// remove it when bfa starting is properly fixed
class On120Arrival : public PlayerScript
{
public:
    On120Arrival() : PlayerScript("On120Arrival") { }

    int QUEST_WOLFSOFFENSIVE_A = 56031;
    int QUEST_WARCHIEFSORDER_H = 56030;

    void OnLevelChanged(Player* player, uint8 oldLevel) override
    {
        if (oldLevel < 120 && player->getLevel() >= 120)
            if (const Quest* quest = sObjectMgr->GetQuestTemplate(player->IsInAlliance() ? QUEST_WOLFSOFFENSIVE_A : QUEST_WARCHIEFSORDER_H))
                player->AddQuest(quest, nullptr);
    }
};

/* Worgen Running Wild spell */
class WorgenRunningWild : public PlayerScript
{
public:
    WorgenRunningWild() : PlayerScript("WorgenRunningWild") { }

    void OnLevelChanged(Player* player, uint8 /*oldLevel*/) override
    {
        if (player->getRace() == RACE_WORGEN && player->getLevel() == 20)
            player->CastSpell(player, SPELL_RUNNING_WILD_LEARN);
    }
};

/* Save all players on logout */
// fixes bug where players are rolled back to previous level on logout
class PlayerSavingOnLogoutFix : public PlayerScript
{
public:
    PlayerSavingOnLogoutFix() : PlayerScript("PlayerSavingOnLogoutFix") { }
	

		
    void OnLogout(Player* player) override
    {
        if (player->getLevel() > MAX_LEVEL)  //above max level server login full crash fix!
        {
            player->SetLevel(MAX_LEVEL);
        }
        ObjectAccessor::SaveAllPlayers();
    }
};

class PlayerScript_Weekly_Spells : public PlayerScript
{
public:
	PlayerScript_Weekly_Spells() : PlayerScript("PlayerScript_Weekly_Spells") {}

    void OnLogin(Player* player, bool /*firstLogin*/) override
    {
        if (!player)
            return;

        if (!sGameEventMgr->IsActiveEvent(130))
        {
            player->RemoveActiveQuest(sObjectMgr->GetQuestTemplate(44175), false);
            player->RemoveAura(225788);
        }
        else
            player->CastSpell(player, 225788, false);

        if (!sGameEventMgr->IsActiveEvent(131))
        {
            player->RemoveActiveQuest(sObjectMgr->GetQuestTemplate(44173), false);
            player->RemoveAura(186403);
        }
        else
            player->CastSpell(player, 186403, false);

        if (!sGameEventMgr->IsActiveEvent(132))
        {
            player->RemoveActiveQuest(sObjectMgr->GetQuestTemplate(44174), false);
            player->RemoveAura(186406);
        }
        else
            player->CastSpell(player, 186406, false);

        if (!sGameEventMgr->IsActiveEvent(133))
        {
            player->RemoveActiveQuest(sObjectMgr->GetQuestTemplate(44172), false);
            player->RemoveAura(186401);
        }
        else
            player->CastSpell(player, 186401, false);

        if (!sGameEventMgr->IsActiveEvent(134))
        {
            player->RemoveActiveQuest(sObjectMgr->GetQuestTemplate(44171), false);
            player->RemoveAura(225787);
        }
        else
            player->CastSpell(player, 225787, false);

    }

    void OnMapChanged(Player* player) override
    {
        if (!player)
            return;

        if (!sGameEventMgr->IsActiveEvent(130))
            player->RemoveAura(225788);
        if (!sGameEventMgr->IsActiveEvent(131))
            player->RemoveAura(186403);
        if (!sGameEventMgr->IsActiveEvent(132))
            player->RemoveAura(186406);
        if (!sGameEventMgr->IsActiveEvent(133))
            player->RemoveAura(186401);
        if (!sGameEventMgr->IsActiveEvent(134))
            player->RemoveAura(225787);

    }
};

class player_level_rewards : public PlayerScript
{
public:
    player_level_rewards() : PlayerScript("player_level_rewards") {}

    void OnLevelChanged(Player* player, uint8 oldLevel) override
    {
        if (oldLevel <= 119 && player->getLevel() >= 120)
        { 
            switch (player->getRace()) // Heritage Armor
            {
                case RACE_VOID_ELF:
                    if (player->GetQuestStatus(49928) == QUEST_STATUS_NONE)
                        if (const Quest * quest = sObjectMgr->GetQuestTemplate(49928))
                            player->AddQuest(quest, nullptr);
                    break;
                case RACE_LIGHTFORGED_DRAENEI:
                    if (player->GetQuestStatus(49782) == QUEST_STATUS_NONE)
                        if (const Quest * quest = sObjectMgr->GetQuestTemplate(49782))
                            player->AddQuest(quest, nullptr);
                    break;
                case RACE_NIGHTBORNE:
                    if (player->GetQuestStatus(49784) == QUEST_STATUS_NONE)
                        if (const Quest * quest = sObjectMgr->GetQuestTemplate(49784))
                            player->AddQuest(quest, nullptr);
                    break;
                case RACE_HIGHMOUNTAIN_TAUREN:
                    if (player->GetQuestStatus(49783) == QUEST_STATUS_NONE)
                        if (const Quest * quest = sObjectMgr->GetQuestTemplate(49783))
                            player->AddQuest(quest, nullptr);
                    break;
                case RACE_DARK_IRON_DWARF:
                    if (player->GetQuestStatus(51483) == QUEST_STATUS_NONE)
                        if (const Quest * quest = sObjectMgr->GetQuestTemplate(51483))
                            player->AddQuest(quest, nullptr);
                    break;
                case RACE_MAGHAR_ORC:
                    if (player->GetQuestStatus(51484) == QUEST_STATUS_NONE)
                        if (const Quest * quest = sObjectMgr->GetQuestTemplate(51484))
                            player->AddQuest(quest, nullptr);
                    break;
                case RACE_ZANDALARI_TROLL:
                    if (player->GetQuestStatus(53721) == QUEST_STATUS_NONE)
                        if (const Quest * quest = sObjectMgr->GetQuestTemplate(53721))
                            player->AddQuest(quest, nullptr);
                    break;
                case RACE_KUL_TIRAN:
                    if (player->GetQuestStatus(53722) == QUEST_STATUS_NONE)
                        if (const Quest * quest = sObjectMgr->GetQuestTemplate(53722))
                            player->AddQuest(quest, nullptr);
                    break;
                case RACE_VULPERA:
                    if (player->GetQuestStatus(58435) == QUEST_STATUS_NONE)
                        if (const Quest * quest = sObjectMgr->GetQuestTemplate(58435))
                            player->AddQuest(quest, nullptr);
                    break;
                case RACE_MECHAGNOME:
                    if (player->GetQuestStatus(58436) == QUEST_STATUS_NONE)
                        if (const Quest * quest = sObjectMgr->GetQuestTemplate(58436))
                            player->AddQuest(quest, nullptr);
                    break;
                default:
                    break;
            }
        }
    }
};


/* BfaCore Free Repack Welcome message */
/*class BfaCoreFreeRepackWelcome : public PlayerScript
{
public:
    BfaCoreFreeRepackWelcome() : PlayerScript("BfaCoreFreeRepackWelcome") { }

    void OnLogin(Player* player, bool) override
    {
        ChatHandler(player->GetSession()).SendSysMessage("|cffFF0000 This is BfaCore Free Repack. Donate to remove ads and limitations.|r");
        ChatHandler(player->GetSession()).SendSysMessage("|cffFF0000 BfaCore official discord: https://discord.gg/57D59ed ShadowCoreTeam@yahoo.com|r");
    }
};*/

/*class BFACoreCredits : public PlayerScript
{
public:
    BFACoreCredits() : PlayerScript("BFACoreCredits") { }

    void OnLogin(Player* player, bool) override
    {
        ChatHandler(player->GetSession()).SendSysMessage("|cffFF0000 This core is powered from BFACore team. https://discord.gg/57D59ed");
    }
};*/

void AddSC_custom_player_script()
{
    RegisterPlayerScript(playerscript_recruiter);
    //RegisterPlayerScript(OnLegionArrival);          // TEMP FIX! Quest 40519 and 43926 - "legion returns". remove it when legion start quests are properly fixed
    //RegisterPlayerScript(On110Arrival);             // TEMP FIX! Quest 43341 - "uniting the isles".
    RegisterPlayerScript(OnBfaArrival);             // TEMP FIX! remove it when lordaeron battle is properly fixed.
    RegisterPlayerScript(On120Arrival);             // TEMP FIX! remove it when bfa starting is properly fixed.
    RegisterPlayerScript(WorgenRunningWild);
    RegisterPlayerScript(PlayerSavingOnLogoutFix);
    //RegisterPlayerScript(BfaCoreFreeRepackWelcome);
    //RegisterPlayerScript(BFACoreCredits);
	new PlayerScript_Weekly_Spells();
	RegisterPlayerScript(player_level_rewards);

}

